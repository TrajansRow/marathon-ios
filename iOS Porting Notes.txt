A list of hacks and modifications needed to port Aleph One source files to iOS.

These are the steps followed to rebase the entire engine from Aleph One into a form that will run as the iOS port.

Resync vcpkg.json, and build dependencies with the iOS arm community triplet.

Remove folder references to Source_Files from the Xcode project
Replace AlephOneSDL/Source_Files with the latest from the Aleph One project using the opengl-es-renderer branch!

Drop the new Source_Files into the Xcode project sidebar. DO NOT create an external build system!

Use "Create Groups", and check all targets.

From the new source tree, remove references to these files from everywhere: Makefile.am, COPYING, README, COPYRIGHT, buildprogram, thread_priority_sdl_win32,  thread_priority_sdl_posix, thread_priority_sdl_dummy, network_dummy.cpp, csalerts.mm, main.cpp (Make sure nothing new and important is in here)

Remove references to the Shaders directory in code, and drop the real Shaders directly in as a folder. Do not add to any targets.

Code changes:

If not using ANGLE, swap in the needed OpenGL and GLES headers in OGL_Headers.h

In lauxlib.c, set this in "int luai_system(const char* command) {":
#ifdef __APPLE__
		#include "TargetConditionals.h"
		#ifdef TARGET_OS_IOS
			return 0;
		#else
			return system(command);
		#endif
#endif

In cspaths, csalerts or anywhere that includes cocoa.h:
#ifdef __APPLE__
		#include "TargetConditionals.h"
		#ifdef TARGET_OS_IOS
			#import <UIKit/UIKit.h>
		#else
			#import <Cocoa/Cocoa.h>
		#endif
#endif

Replace alerts with stuff like (returning 0 or void as needed:
#ifdef TARGET_OS_IOS
	//NOT IMPLEMENTED!
	return 0;
#else
	...
#endif

Before any checks for useSGISMipmaps, add:
#ifdef TARGET_OS_IOS
				bool useSGISMipmaps=0;
#endif

Deleted the iOS image loader! 

Changed ofstream thumbFile; to boost_swap_impl::ofstream thumbFile; for save game thumbnails

In QuickSave.h, add these:
std::string build_save_metadata(QuickSave& save);
bool build_map_preview(std::ostringstream& ostream);

In QuickSaver.cpp, change this to non-static:
bool build_map_preview(std::ostringstream& ostream)

Make this non-static in shell.cpp:
void process_event(const SDL_Event &event);

In devices.cpp, change line_is_within_range to non-static

In, return a static name for now:std::string get_application_name()
Also need to add #include "alephversion.h" To the top of shell.cpp

In shell.cpp, right before const string data_env = a1_getenv("ALEPHONE_DATA");, change default_data_dir using (also include the healer header file): 
#if TARGET_OS_IPHONE
  default_data_dir = getDataDir();
  local_data_dir = getLocalDataDir();
  //log_dir = getLocalTmpDir(); //DCW ok, this is not great because the log file grows forever. Commenting out.
#endif

Add these in screen.cpp:
		// DCW force OpenGL ES 3.x. The default would otherwise be ES 2.
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);

In void start_game() in interface.cpp, add helperBringUpHUD(); to the end of the function. Also add #import "AlephOneHelper.h" to the top of the file.

Apply this in interface.cpp:
case mInterface:
			switch(menu_item)
			{
				case iNewGame:
					// iOS Start a new game with a dialog!
					if ( helperNewGame() ) {
						begin_game(_single_player, cheat);
					}

Also, in begin_game(), right before "// ZZZ: let the user use his behavior modifiers in single-player." Add this:
			// iOS set custom entry level number
			entry.level_number = helperGetEntryLevelNumber();


In joystick_sdl.cpp, at the top of joystick_added() add:
	//On iOS, we handle the joystick elsewhere - double input is not ideal and may cause jitter. Just return.
	return;


In screen.cpp, change initialization resolution to:  if (desktop.w >= 640/2 && desktop.h >= 480/2) //DCW divided original values by two, since retina displays have a smaller dimension in points than the native resolution.

Also do: 
int Screen::window_height()
{
	return std::max(static_cast<short>(480/2), screen_mode.height); //DCW added /2 due to this probably being a retina display on iOS
}

int Screen::window_width()
{
	return std::max(static_cast<short>(640/2), screen_mode.width);  //DCW added /2 due to this probably being a retina display on iOS
}


//YAY! The magic thing that makes rendering work!
***Does the GL ES branch need this too?
In OGL_FBO.cpp in deactive():
		//DCW binding to framebuffer 0 doesn't switch to the on-screen buffer on mobile.
		//Instead, call this convneience function to do something more likely to work.
		if ( prev_fbo == 0 ) {
			glBindFramebuffer(GL_FRAMEBUFFER, 1);
			glBindRenderbuffer(GL_RENDERBUFFER, 1);
		} else {
			glBindFramebuffer(_fboTarget, prev_fbo);
		}

In mouse_sdl.cpp, #import "AlephOneHelper.h". Also add this to enter_mouse:
//DCW clear mouse deltas to avoid a large initial jump.
		float dx, dy;
		slurpMouseDelta(&dx, &dy);

And add this to mouse_idle:    
    slurpMouseDelta(&dx, &dy);
    if(dx>0 || dy>0)
    {
      snapshot_delta_x = 0;
      snapshot_delta_y = 0;
    }

In vbl.cpp, add #include "AlephOneHelper.h" and also add to the Parse Keymap section.
if (key_map[code] || fake_key_map[code]) //iOS virtual input uses fake_key_map

In vbl.cpp, change to:
flags = build_terminal_action_flags((char *)/*key_map*/fake_key_map); //iOS changed to fake_key_map



In preprocess_map_sdl.cpp, att the #include "AlephOneHelper.h" header and override save_game with:
bool save_game(void)
{
	//On iOS, just save with current saved game by calling the helper
	helperSaveGame();
	return true;


In interface.cpp, override handle_load_game with:
void handle_load_game(
	void)
{
  // On iOS, just call helper function
  helperHandleLoadGame();
  return;

In Interface.cpp, override dialog in should_restore_game_networked (before d.run) with:
	//iOS TODO: Test enable multiplayer restore. Currently, the dialog may not be shown.
	if(dynamic_world->player_count != 0) {
		switchToSDLMenu();
	}
	return theRestoreAsNetgameToggle->get_selection(); //iOS restore override

In Console.cpp, add in the "AlephOneHelper.h" header and override the keyboard input in Console::activate_input (before SDL_StartTextInput()) like this:
	//Alternate iOS Keyboard input.
	if(game_is_networked)
		getSomeTextFromIOS("Chat", "");
	else
		getSomeTextFromIOS("Console", "");
	return;

Do the same in sdl_widgits.cpp first thing in w_text_entry::click():
	//This might be a good place to handle text input differently on iOS.
	char *label = this->associated_label->text;
	const char *currentText = this->get_text();
	get_owning_dialog()->activate_widget(this);
		//If this widget can't activate, don't ask for input.
	if(active) {
		dirty = true;
		getSomeTextFromIOS(label, currentText);
		this->set_text("");
	}
	return;

For the above to work, modify "class w_static_text : public widget" in sdl_widgits.h:
	char *text; // Make not protected for iOS
protected:
	//char *text; // Make not protected for iOS

Also in sdl_widgets.cpp, in w_text_entry::set_active(bool new_active), disable the SDL keyboard:
		//SDL_StartTextInput(); //When using the iOS keyboard input helper, we only want to listen for input here and not display the keyboard (which SDL_StartTextInput does).


In networkdialogs.cpp, in both JoinDialog::JoinNetworkGameByRunning () and SetupNetgameDialog::SetupNetworkGameByRunning (right after CStringPref namePref (player_preferences->name, MAX_NET_PLAYER_NAME_LENGTH);)...  Add #include "AlephOneHelper.h" to the top and then add this to avoid a generic "mobile' name by adding these lines:

	//On iOS if we get a generic mobile name from the system, replace it with something random.
	if(strcmp(player_preferences->name, "mobile") == 0){
		namePref.bind_import(randomName31());
	}


In Plugins.cpp add "AlephOneHelper.h", and then also add the iOS plugin filters to Plugin::valid():
//Plugin filters for iOS
	if(useClassicVisuals()) {
		if(
				//M1
				strcmp(name.c_str(), "TTEP v7") == 0 ||
				strcmp(name.c_str(), "TTEP") == 0 ||
				strcmp(name.c_str(), "Updated Starscape") == 0 ||
				strcmp(name.c_str(), "M1 Hd Weapon Pack") == 0 ||
			 
				//M2
				strcmp(name.c_str(), "HD Monsters") == 0 ||
				strcmp(name.c_str(), "HD Textures") == 0 ||
			 
				//M2&M3
				strcmp(name.c_str(), "HD Weapons") == 0 ||
			 
				//Any CFP
				strncmp(name.c_str(), "CFP", 3) == 0 ||
			 
				//M3
				strcmp(name.c_str(), "Gorans Highres Landscapes") == 0 ||
				strcmp(name.c_str(), "Gorans Jjarro Set DDS") == 0 ||
				strcmp(name.c_str(), "Gorans Lava Set 2.0") == 0 ||
				strcmp(name.c_str(), "Gorans Pfhor Set DDS") == 0 ||
				strcmp(name.c_str(), "Gorans Sewage Set DDS") == 0 ||
				strcmp(name.c_str(), "Gorans Pfhor Set DDS") == 0
				) {
			return false;
		}
	}


In screen.cpp, map_is_translucent(void), add the "AlephOneHelper.h" header and change to:
return ( (screen_mode.translucent_map || !useClassicVisuals()) && NetAllowOverlayMap()); //iOS automatically enabled translucent map for HD visuals.

In preferences.cpp, add the "AlephOneHelper.h" header. Edit graphics_preferences_tree() so that before any tex.put_attr stuff, we then run:
	//Apply iOS texture filtering
			if(useClassicVisuals()){
				Config.FarFilter=2;
				Config.NearFilter=2;
			} else {
				Config.FarFilter=1;
				Config.NearFilter=1;
			}


		//For iOS, use 3D perspective
		graphics_preferences->OGL_Configure.Flags &= ~OGL_Flag_MimicSW;
		
		//For iOS, always enable blur/bloom. We can still skip the bloom pass later based on prefs.
		graphics_preferences->OGL_Configure.Flags |= OGL_Flag_Blur;
		
		//For iOS, enable bump mapping as desired
		if (useBumpMapping()) {
			graphics_preferences->OGL_Configure.Flags |= OGL_Flag_BumpMap;
		} else {
			graphics_preferences->OGL_Configure.Flags &= ~OGL_Flag_BumpMap;
		}
		
		//for iOS, set FPS target higher
		graphics_preferences->fps_target = iOSFPSTarget();
		
		//Show iOS FPS if desired.
		extern bool displaying_fps;
		displaying_fps = showiOSFPS();


In RenderRasterize_shader -> render_tree(), change this line to:
if (useShaderPostProcessing() && current_player->infravision_duration == 0 &&
		TEST_FLAG(Get_OGL_ConfigureData().Flags, OGL_Flag_Blur) &&
		blur.get())


In screen_shared_h -> update_fps_display(), add the "AlephOneHelper.h" header and then add eight spaces in front of the fps string so that it isn't cut off by rounded corners:
			sprintf(fps, "        %0.f fps %s (%d)", fps_counter.get(), ms, CAFrameRate());

To avoid crashes, also increase the size of the string used by adding a bunch of spaces to it:
     char fps[sizeof("1000 fps (10000 ms)                        ")];


Enable smart triggerUsing these steps:

In scottish_textures.h, add this near the end (just before constructor) for rectangle_definition:
bool isLivingMonster; //iOS smart trigger hint

In RenderPlaceObjs.cpp , add this to the top:
#include "monsters.h" //Needed for iOS smart trigger

Then also add this in build_render_object(), right before render_object->rectangle.flags= 0;:
//Set iOS smart trigger hint
				render_object->rectangle.isLivingMonster= 0;
				if (GET_OBJECT_OWNER(object) == _object_is_monster)
				{
					struct monster_data *monster= get_monster_data(object->permutation);
					if (monster && !MONSTER_IS_DYING(monster)) {
						render_object->rectangle.isLivingMonster=1;
					}
				}

In RenderRasterizeShader add the "AlephOneHelper.h" header, and then in _render_node_object_helper(), add this before the first DC()->addTriangleFan call:
//iOS Smart trigger.
	GLfloat spriteOnScreen[12] = {vertex_array[0], vertex_array[1], vertex_array[2],
																vertex_array[3], vertex_array[4], vertex_array[5],
																vertex_array[6], vertex_array[7], vertex_array[8],
																vertex_array[9], vertex_array[10], vertex_array[11]};
		//Convert sprite coordinates to screen coordinates. Hopefully the right matrix is enabled, otherwise this would behave strangely.
	MatrixStack::Instance()->transformVertex(spriteOnScreen[0], spriteOnScreen[1], spriteOnScreen[2]);
	MatrixStack::Instance()->transformVertex(spriteOnScreen[3], spriteOnScreen[4], spriteOnScreen[5]);
	MatrixStack::Instance()->transformVertex(spriteOnScreen[6], spriteOnScreen[7], spriteOnScreen[8]);
	MatrixStack::Instance()->transformVertex(spriteOnScreen[9], spriteOnScreen[10], spriteOnScreen[11]);
		//Sprite is centered horizontally if index 0 and 3 are different signs.
		//Sprite is centered vertically if index 4 and 7 are different signs.
	if( rect.isLivingMonster ) {
		if ( (spriteOnScreen[0] >= 0 && spriteOnScreen[3] <= 0) || (spriteOnScreen[0] <= 0 && spriteOnScreen[3] >= 0) ) {
				if ( (spriteOnScreen[4] >= 0 && spriteOnScreen[7] <= 0) || (spriteOnScreen[4] <= 0 && spriteOnScreen[7] >= 0) ) {
						monsterIsCentered();
				}
		}
	}

Finally, in screen.cpp -> render_screen(), right before // Render world view, call this:
clearSmartTrigger(); //Reset iOS smart trigger


In interface.cpp, Replace both instances of "display_net_game_stats()" with:
			display_net_game_stats_helper(); //iOS needs to handle hiding the HUD before showing netstats.

In network_dialogs.cpp, in SdlGatherDialog(), replace the line "autogather_placer->dual_add(autogather_w->label("Auto-Gather"), m_dialog);" with:

In network_udp.cpp...

Add the include:
#include <sys/socket.h> //Needed for setting QOS on iOS


At the top of receive_thread_function(void*), add:
pthread_set_qos_class_self_np(QOS_CLASS_USER_INTERACTIVE,0); //Set interactive QoS for iOS

In NetDDPOpenSocket(), right before "// Set up socket set" add this:

				//Set an appropriate network socket service type vfor iOS. First connection listening when hosting.
				int	theSocketFD = ((int*)sSocket)[1];
				int st = NET_SERVICE_TYPE_VO;
				setsockopt(theSocketFD, SOL_SOCKET, SO_NET_SERVICE_TYPE, (void *)&st, sizeof(st));




*****TODOs!*****


***Add check for allow local network connections permission in the app, because denying this can cause a silent failure to find net games. '"Infinity" would like to find and connect to devices on your local network.'

Fix weapons reticle refresh check
Add in switchToSDLMenu(); and display_net_game_stats_helper() stuff!

Try removing ffmpeg from vcpkg build.

Determine if changing 1 to _fbo here is correct:
  glBindFramebuffer(GL_FRAMEBUFFER, _fbo);
  glBindRenderbuffer(GL_RENDERBUFFER, _fbo);


In + (void)setAlephOnePreferences:, set the volume a new way

Remove anything with a comment like: //Still needed for iOS 6-19-24?

Did we need SDL_MouseInit(); for anything?

Remove AlephOneAcceleration files?

Verify the SDL mouse event works in - (void)handleTapFrom:(UITapGestureRecognizer *)recognizer.

Do we need esutils files?

Done?: Check out and see if we need #include "game_window.h"for this line: //Still needed for iOS 6-19-24? mark_shield_display_as_dirty();
